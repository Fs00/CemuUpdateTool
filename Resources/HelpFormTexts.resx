<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="baseRtfText" xml:space="preserve">
    <value>{\rtf1\ansi\ansicpg1252\deff0\deflang1040{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}{\f1\fnil\fcharset0 Courier New;}}</value>
  </data>
  <data name="homeFormText" xml:space="preserve">
    <value>{\b WHICH MODE DO I CHOOSE?}\par\fs19
\sb100 {\i Migrate} mode is used to copy all data from a Cemu installation to another one. You can obviously control which data must be copied by editing settings in Options window. It is very useful if you want to keep both an older version and the last one to avoid regressions when they happen.\par
\sb90 {\i Download and Migrate} mode works same as previous one, with the only difference that the program downloads and extracts the Cemu archive (by default the latest version, but you can choose an older one) in the destination folder you selected and then migrates all data. This spares you the procedure of downloading manually Cemu from the website.\par
{\i Update} mode, instead, lets you update an existing Cemu installation by simply replacing the executable and translation files with the ones from the latest version, plus some other user-selectable tasks.</value>
  </data>
  <data name="migrationFormText" xml:space="preserve">
    <value>{\b HOW DO I PROCEED?}\par\fs19
\sb100 You need to do just two steps from here: select the source Cemu folder (the one where data must be migrated from) and the destination one. Then click start: depending on the mode you've chosen ({\i Migrate} or {\i Download and Migrate}), the program will perform all the steps in order to migrate the data.\par
\sb90 If you are in {\i Download and Migrate} mode, you can choose to download an older Cemu version instead of the latest one by replacing "Latest" with the version number you want.\par
The Details log will show you all the information about the process, including warnings and errors.\par
To decide which data must be copied and what the program must do before and after migration, head to Options.</value>
  </data>
  <data name="optionsFormText" xml:space="preserve">
    <value>{\b WHERE AND HOW ARE OPTIONS SAVED?}\par\fs19
\sb100 By default, options are lost when you exit the program. To save them in a file so that they can be loaded each time you use the tool, you must check "Store settings in a file" in Features tab.\par
\sb90 Then, you can choose whether options file (which is a text file called settings.dat) must be saved either in the same folder as the executable or in {\i %AppData%\\Fs00\\CemuUpdateTool}. If at start-up the program detects an options file in both folders, priority is given to the one in executable folder, unless the tool is launched with the command line parameter \f1 prefer-appdata-config\f0.\par
Inside the file, settings are organized in sections marked by a number. You will never need to edit it manually.\par
\sb160 \fs23 {\b WHICH OPTIONS ARE AVAILABLE?}\par\fs19
\sb100 As you may have seen, options are divided in 3 tabs:\par
\pard\sb90 {\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent0{\pntxtb\'B7}}\fi-360\li720\ri120\f0\fs19 {\b Folders.} In this section, you have the opportunity to choose which Cemu folders will be copied. If you want to define other folders different than default ones, you need to add them through the editing window that you can open by clicking on "Manage custom folders". Please take note that {\ul only checked folders will be copied}, and that the path you provide must be relative to Cemu directory (e.g. {\i shaderCaches\\precompiled)}.\line
Starting from version 2.1, you can also define custom files to be copied, in the same way as folders. You can edit them by clicking on "Manage custom files".\line
In addition, you can warn the tool that you're using a custom mlc01 path (which is the subfolder where Cemu puts savegames and DLCs). If that option is true, the program will ignore that folder when migrating from a version higher than 1.10 and if the custom path is set, Cemu desktop shortcut will be created adding the '-mlc' parameter accordingly.\par
{\pntext\f2\'B7\tab}{\b Features.} This tab gives you the ability to enable/disable migration-related features - which consist in: wiping prior destination folder contents, asking for the creation of Cemu desktop shortcut and setting compatibility options for Cemu executable - as well as decide if options must be saved in a file and where (see above).\par
{\pntext\f2\'B7\tab}\f0 {\b Download.} Here you can change the remote location where Cemu versions are downloaded from. You will have to touch it only if Cemu developers change their download repository.\par</value>
  </data>
  <data name="updateFormText" xml:space="preserve">
    <value>{\b HOW DO I PROCEED?}\par\fs19
\sb100 Basically, you just have to provide the path to the folder that contains the Cemu installation that will be updated and click Start.\par
\sb90 If the option "Update game profiles" is checked, the content of gameProfiles folder will be replaced with the one from the downloaded version. If you have modified your game profiles, you should leave it unchecked because otherwise you'll lose your edits.\par
"Delete precompiled caches" option lets you choose to keep full precompiled shader caches or not after the update. {\b You will NOT lose your shader caches if this is enabled}, since shaders will be recompiled using transferable caches. Take note that Cemu is able to detect and regenerate automatically outdated caches, so this option doesn't offer noticeable benefits other than cleaning up space on disk.\par
The Details log will show you all the information about the process, including warnings and errors.\par</value>
  </data>
</root>