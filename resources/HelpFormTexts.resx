<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="baseRtfText" xml:space="preserve">
    <value>{\rtf1\ansi\ansicpg1252\deff0\deflang1040{\fonttbl{\f0\fnil\fcharset0 Segoe UI;}}</value>
  </data>
  <data name="homeFormText" xml:space="preserve">
    <value>{\b WHICH MODE DO I CHOOSE?}\par
\fs8\par\fs19
{\i Migrate} mode is used to copy all data from a Cemu installation to another one. You can obviously control which data must be copied and which not by editing settings in Options window. It is very useful if you want to keep both the older version and the last one to avoid regressions when they happen.\par
{\i Download and Migrate} mode works same as previous one, with the only difference that the program downloads and extracts the latest Cemu version in the folder you selected and then migrates all data. This spares you the procedure of downloading manually Cemu from the website.</value>
  </data>
  <data name="migrationFormText" xml:space="preserve">
    <value>{\b HOW DO I PROCEED?}\par
\fs8\par\fs19
You need to do just two steps from here: select the source Cemu folder (the one where data must be migrated from) and the destination one. Then click start: depending on the mode you've chosen (Migrate or Download and Migrate), the program will perform all the steps in order to migrate the data.\par
The Details log will show you all the information about the process, including warnings and errors.\par
To decide which data must be copied and what the program must do before and after the migration, head to Options.</value>
  </data>
  <data name="optionsFormText" xml:space="preserve">
    <value>{\b WHERE AND HOW ARE OPTIONS SAVED?}\par
\fs8\par\fs19
By default, options are lost when you exit the program. To save them in a file so that they can be loaded each time you use the tool, you must check "Store settings in a file" in Features tab.\par
Then, you can choose whether options file (which is a text file called settings.dat) must be saved either in the same folder as the executable or in {\i %AppData%\\Fs00\\CemuUpdateTool}. If at start-up the program detects an options file in both folders, priority is given to the one in executable folder.\par
Inside the file, settings are organized in sections marked by a number. Except section #0 (which you'll learn about later), you will never need to edit it manually.\par
\par
\fs23 {\b WHICH OPTIONS ARE AVAILABLE?}\par
\fs8\par\fs19
As you may have seen, options are divided in 3 tabs:\par
\pard{\pntext\f2\'B7\tab}{\*\pn\pnlvlblt\pnf2\pnindent0{\pntxtb\'B7}}\fi-360\li720\ri120\b\f0\fs19\lang1040 Folders.\b0  In this section, you have the opportunity to choose which Cemu folders will be copied. If you want to define other folders different than default ones, you need to add them manually to settings file under section #0 in the following format: \i folder,true\i0 , whereas {\i folder} is the path relative to Cemu directory. You can see if custom folders have been correctly detected just looking at Total value in Custom folders box.\line
In addition, you can warn the tool that you're using a custom mlc01 path (which is the subfolder where Cemu puts savegames and DLCs). If that option is true, the program will ignore that folder when migrating from a version higher than 1.10 and if the custom path is set, Cemu desktop shortcut will be created adding the '-mlc' parameter accordingly.
\line\b\i NOTE:\b0  when the option "Copy settings file" is enabled, the program will actually copy ONLY settings.bin and not the settings.xml file introduced in 1.11.6 for game list. This will be addressed in a future version.\i0\par
{\pntext\f2\'B7\tab}\b Features.\b0  This tab gives you the ability to enable/disable migration-related features - which consist in: wiping destination folder contents coming from the original Cemu archive, asking for the creation of Cemu desktop shortcut and setting compatibility options for Cemu executable - as well as decide if options must be saved in a file and where (see above).\f1\fs18\lang1026\par
{\pntext\f2\'B7\tab}\b\f0\fs19\lang1040 Download.\b0  Here you can change the remote location where Cemu versions are downloaded. You will have to touch it only if Cemu devs change their download repository.\f1\fs18\lang1026\par</value>
  </data>
</root>